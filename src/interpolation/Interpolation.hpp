//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////
//														//
//		Written by: Vicente José Bevia Escrig			//
//		Mathematics Ph.D. student (2020-2024) at:		//
//		Instituto de Matemática Multidisciplinar,		//
//		Universitat Politècnica de València, Spain		//
//														//
//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////
#ifndef __INTERPOLATION_HPP__
#define __INTERPOLATION_HPP__

#include "include/headers.hpp"
#include "include/Case_definition.hpp"
#include "include/utils/numeric_defs.hpp"
#include "include/utils/window.cuh"

#include "probabilityDistributions/Probability.hpp"
#include "mesh/Domain.hpp"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class InterpHandle {
	// Attributes
public:
	thrust::device_vector<floatType> GPU_R;
	thrust::device_vector<floatType> GPU_temp;
	thrust::device_vector<floatType> GPU_AP;
	thrust::device_vector<floatType> GPU_P;

public:
	// Constructor
	hostFunction InterpHandle(uintType size = 1);

	// Methods	
	void resize(uintType size = 1);

};


deviceFunction inline floatType RBF(const floatType& SuppRBF, const floatType& inputNormalized) {

#if PHASE_SPACE_DIMENSIONS == 1
	const double Mass_RBF = 0.333383333333333;

#elif PHASE_SPACE_DIMENSIONS == 2
	const double Mass_RBF = 0.4487989332761852; // this is actually the: int_0^1 phi(r)r dr

#elif PHASE_SPACE_DIMENSIONS == 3
	const double Mass_RBF = 0.2991993007905369;

#elif PHASE_SPACE_DIMENSIONS == 4
	const double Mass_RBF = 0.19582548282938347;
#endif

	return (floatType)powf(fmaxf(0, 1 - inputNormalized), 4) * (4 * inputNormalized + 1) / Mass_RBF / powf(SuppRBF, PHASE_SPACE_DIMENSIONS); // We multiply by this last factor to get the L1-normalized RBF

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


__global__ void UPDATE_VEC(
	floatType* x, const floatType* x0, const floatType scalar, const floatType* v, const intType Max_Length);

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


__global__ void MATRIX_VECTOR_MULTIPLICATION(
	floatType* X, const floatType* x0, const intType* Matrix_idxs, const floatType* Matrix_entries, const intType total_length, const intType Max_Neighbors);


hostFunction intType CONJUGATE_GRADIENT_SOLVE(thrust::device_vector<floatType>& GPU_lambdas,
	thrust::device_vector<intType>& GPU_Index_array,
	thrust::device_vector<floatType>& GPU_Mat_entries,
	thrust::device_vector<floatType>& GPU_AdaptPDF,
	InterpHandle& interpVectors,
	const intType					Total_Particles,
	const intType					MaxNeighborNum,
	const uintType					max_steps,
	const floatType							in_tolerance);

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

__global__ void RESTART_GRID_FIND_GN(Particle* Particle_Positions,
	floatType* PDF,
	floatType* lambdas,
	const parameterPair* parameter_mesh,
	const intType* n_Samples,
	const floatType 	 		search_radius,
	const uintType	 		Adapt_Pts,
	const uintType	 		Block_samples,
	const uintType	 		offset,
	const cartesianMesh 	Domain,
	const cartesianMesh	Expanded_Domain);

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

__global__ void RESTART_GRID_FIND_GN(Particle* Particle_Positions,
	floatType* PDF,
	floatType* lambdas,
	const Param_vec<PHASE_SPACE_DIMENSIONS>* Impulse_weights,
	const floatType 	search_radius,
	const uintType	Adapt_Pts,
	const uintType	Current_sample,
	const cartesianMesh	Domain,
	const cartesianMesh	Expanded_Domain);

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// @brief This function makes sure that the PDF does not have any negative values! (Having this enforced by the interpolation would've been wonderful)
/// @param PDF 
/// @param Grid_Nodes 
/// @return 

__global__ void CORRECTION(floatType* PDF, const intType Grid_Nodes);

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#endif